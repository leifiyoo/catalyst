import { BrowserWindow } from "electron";
import { spawn, ChildProcess, execFile } from "child_process";
import { ConsoleLine, ServerStats, ServerStatusUpdate } from "@shared/types";
import { getServer, getServers, getServerProperties, updateServerStatus, updateServerSettings, installCatalystPlugin } from "./server-manager";
import { getRequiredJavaVersion, ensureJavaInstalled, getJavaHome } from "./java-manager";
import { startNgrokTunnel, isNgrokEnabled, isAuthtokenConfigured } from "./ngrok-manager";

const runningServers = new Map<string, ChildProcess>();
const serverStatsTimers = new Map<string, ReturnType<typeof setInterval>>();
const serverStatsData = new Map<string, ServerStats>();
const serverReady = new Map<string, boolean>();
const lastMemCommandAt = new Map<string, number>();
const serverLogs = new Map<string, ConsoleLine[]>();
const serverRestarting = new Map<string, boolean>(); // Track if server is restarting
const MAX_LOG_LINES = 500;
const ANSI_ESCAPE_PATTERN = /\x1b\[[0-9;]*[A-Za-z]/g;

// Lines generated by our internal stats polling that should be hidden from console
const STATS_FILTER_PATTERNS = [
  /^> tps$/,
  /^\[.*\]: Showing TPS for/,
  /^\[.*\]: TPS from last/,
  /^\[.*\]: .*\d+\.\d+.*\d+\.\d+.*\d+\.\d+/,
  /^\[.*\]: Unknown command\. Type "\/help" for help\./,
  /^\[.*\]: \[\?\]/,
  /^\[.*\]: \[\?\].*TPS from last/i,
  /^\[.*\]: \[\?\].*Tick durations/i,
  /^\[.*\]: \[\?\].*CPU usage/i,
  /^> memory$/i,
  /^\[.*\]: Memory usage/i,
  /^\[.*\]: Free memory:/i,
  /^\[.*\]: Max memory:/i,
  /^\[.*\]: Allocated memory:/i,
  /^\[.*\]: Current Memory Usage:/i,
];

// Track windows where stats polling output should be hidden
const internalPollUntil = new Map<string, number>();
const userStatsBypassUntil = new Map<string, number>();
const disableInServerStats = new Map<string, boolean>();

const IN_SERVER_STATS_FRAMEWORKS = new Set(["Paper", "Purpur"]);

function stripAnsi(text: string): string {
  return text.replace(ANSI_ESCAPE_PATTERN, "");
}

function supportsInServerStats(framework: string): boolean {
  return IN_SERVER_STATS_FRAMEWORKS.has(framework);
}

function canUseInServerStats(serverId: string, framework: string): boolean {
  if (!supportsInServerStats(framework)) return false;
  return !disableInServerStats.get(serverId);
}

function isStatsLine(serverId: string, line: string): boolean {
  const now = Date.now();
  const bypassUntil = userStatsBypassUntil.get(serverId) ?? 0;
  if (now < bypassUntil) return false;

  const pollUntil = internalPollUntil.get(serverId) ?? 0;
  if (now > pollUntil) return false;

  return STATS_FILTER_PATTERNS.some((pattern) => pattern.test(line));
}

function buildJavaArgs(ramMB: number, jarFile: string = "server.jar"): string[] {
  return [
    `-Xms${ramMB}M`,
    `-Xmx${ramMB}M`,
    "-XX:+AlwaysPreTouch",
    "-XX:+DisableExplicitGC",
    "-XX:+ParallelRefProcEnabled",
    "-XX:+PerfDisableSharedMem",
    "-XX:+UnlockExperimentalVMOptions",
    "-XX:+UseG1GC",
    "-XX:G1HeapRegionSize=8M",
    "-XX:G1HeapWastePercent=5",
    "-XX:G1MaxNewSizePercent=40",
    "-XX:G1MixedGCCountTarget=4",
    "-XX:G1MixedGCLiveThresholdPercent=90",
    "-XX:G1NewSizePercent=30",
    "-XX:G1RSetUpdatingPauseTimePercent=5",
    "-XX:G1ReservePercent=20",
    "-XX:InitiatingHeapOccupancyPercent=15",
    "-XX:MaxGCPauseMillis=200",
    "-XX:MaxTenuringThreshold=1",
    "-XX:SurvivorRatio=32",
    "-Dusing.aikars.flags=https://mcflags.emc.gs",
    "-Daikars.new.flags=true",
    "-jar",
    jarFile,
    "nogui",
  ];
}

function sendConsoleLine(
  mainWindow: BrowserWindow,
  serverId: string,
  text: string,
  type: ConsoleLine["type"]
) {
  const line: ConsoleLine = {
    timestamp: new Date().toISOString(),
    text,
    type,
  };

  if (!serverLogs.has(serverId)) {
    serverLogs.set(serverId, []);
  }

  const logs = serverLogs.get(serverId)!;
  logs.push(line);
  if (logs.length > MAX_LOG_LINES) {
    logs.shift();
  }

  if (mainWindow.isDestroyed()) return;
  mainWindow.webContents.send("consoleOutput", serverId, line);
}

function sendStatusUpdate(mainWindow: BrowserWindow, update: ServerStatusUpdate) {
  if (mainWindow.isDestroyed()) return;
  mainWindow.webContents.send("serverStatus", update);
}

function sendStats(mainWindow: BrowserWindow, stats: ServerStats) {
  if (mainWindow.isDestroyed()) return;
  mainWindow.webContents.send("serverStats", stats);
}

function parseStatsFromLine(serverId: string, line: string): void {
  const stats = serverStatsData.get(serverId);
  if (!stats) return;

  const normalizedLine = stripAnsi(line);

  // Detect server fully loaded: "Done (X.XXXs)! For help, type "help""
  if (/Done \(\d+\.\d+s\)/.test(normalizedLine)) {
    serverReady.set(serverId, true);
  }

  // Detect server restart command issued (for auto-restart on exit)
  // Pattern: "Server is restarting" or "[RestartCommand]" or "Startup script...does not exist"
  if (/Server is restarting/i.test(normalizedLine) || 
      /\[RestartCommand\]/i.test(normalizedLine) ||
      /Startup script.*does not exist/i.test(normalizedLine)) {
    serverRestarting.set(serverId, true);
  }

  // Parse player join
  const joinMatch = normalizedLine.match(/\]: (\S+) joined the game/);
  if (joinMatch) {
    const name = joinMatch[1];
    if (!stats.onlinePlayers.includes(name)) {
      stats.onlinePlayers.push(name);
      stats.playerCount = stats.onlinePlayers.length;
    }
  }

  // Parse player leave
  const leaveMatch = normalizedLine.match(/\]: (\S+) left the game/);
  if (leaveMatch) {
    const name = leaveMatch[1];
    stats.onlinePlayers = stats.onlinePlayers.filter((p) => p !== name);
    stats.playerCount = stats.onlinePlayers.length;
  }

  // Parse TPS from Paper's "tps" command response
  // Format: "TPS from last 1m, 5m, 15m: *20.0, *20.0, *20.0"
  // The ยง-color codes are stripped, but * prefix may remain
  const tpsMatch = normalizedLine.match(/TPS from last .+?:\s+\*?([\d.,]+)/);
  if (tpsMatch) {
    const tpsValue = tpsMatch[1].replace(",", ".");
    stats.tps = parseFloat(tpsValue);
  }

  // Parse max players from server startup log or list command
  const maxPlayersMatch = normalizedLine.match(/of a max of (\d+) players/i);
  if (maxPlayersMatch) {
    stats.maxPlayers = parseInt(maxPlayersMatch[1], 10);
  }

  // Parse memory from Paper's internal mem output
  // Format varies, common: "Current Memory Usage: X MB / Y MB"
  // or "Free memory: X MB / Total: Y MB / Max: Z MB"
  const memCurrentMatch = normalizedLine.match(/Current Memory Usage:\s*([\d,]+)\s*MB\s*\/\s*([\d,]+)\s*MB/i);
  if (memCurrentMatch) {
    stats.memoryUsedMB = parseInt(memCurrentMatch[1].replace(/,/g, ""), 10);
    stats.memoryMaxMB = parseInt(memCurrentMatch[2].replace(/,/g, ""), 10);
    lastMemCommandAt.set(serverId, Date.now());
  }

  const memUsageMatch = normalizedLine.match(/Memory usage:\s*([\d,]+)\s*MB(?:\s*\/\s*([\d,]+)\s*MB)?/i);
  if (memUsageMatch) {
    stats.memoryUsedMB = parseInt(memUsageMatch[1].replace(/,/g, ""), 10);
    if (memUsageMatch[2]) {
      stats.memoryMaxMB = parseInt(memUsageMatch[2].replace(/,/g, ""), 10);
    }
    lastMemCommandAt.set(serverId, Date.now());
  }

  const memFreeMatch = normalizedLine.match(/Free memory:\s*([\d,]+)\s*MB\s*\/\s*Total:\s*([\d,]+)\s*MB\s*\/\s*Max:\s*([\d,]+)\s*MB/i);
  if (memFreeMatch) {
    const freeMB = parseInt(memFreeMatch[1].replace(/,/g, ""), 10);
    const totalMB = parseInt(memFreeMatch[2].replace(/,/g, ""), 10);
    const maxMB = parseInt(memFreeMatch[3].replace(/,/g, ""), 10);
    stats.memoryUsedMB = Math.max(0, totalMB - freeMB);
    stats.memoryMaxMB = maxMB;
    lastMemCommandAt.set(serverId, Date.now());
  }

  // Alternative format: "Allocated memory: X MB / Max memory: Y MB"
  const memAllocMatch = normalizedLine.match(/Allocated memory:\s*([\d,]+)\s*MB/i);
  if (memAllocMatch) {
    stats.memoryUsedMB = parseInt(memAllocMatch[1].replace(/,/g, ""), 10);
  }
  const memMaxMatch = normalizedLine.match(/Max memory:\s*([\d,]+)\s*MB/i);
  if (memMaxMatch) {
    stats.memoryMaxMB = parseInt(memMaxMatch[1].replace(/,/g, ""), 10);
  }
}

/**
 * Get memory usage (in MB) of a process by PID using OS-level tools.
 * Works on Windows (tasklist) and Unix (ps).
 */
function getProcessMemoryMB(pid: number): Promise<number | null> {
  // Validate PID is a positive integer to prevent injection
  if (!Number.isInteger(pid) || pid <= 0) {
    return Promise.resolve(null);
  }

  return new Promise((resolve) => {
    if (process.platform === "win32") {
      execFile(
        "tasklist",
        ["/FI", `PID eq ${pid}`, "/FO", "CSV", "/NH"],
        { timeout: 5000 },
        (err, stdout) => {
          if (err) return resolve(null);
          // Output format: "java.exe","1234","Console","1","123,456 K"
          const match = stdout.match(/"([0-9,\.]+)\s*K"/);
          if (match) {
            const kb = parseInt(match[1].replace(/[.,]/g, ""), 10);
            resolve(Math.round(kb / 1024));
          } else {
            resolve(null);
          }
        }
      );
    } else {
      // macOS / Linux: use ps to get RSS in KB
      execFile(
        "ps",
        ["-o", "rss=", "-p", String(pid)],
        { timeout: 5000 },
        (err, stdout) => {
          if (err) return resolve(null);
          const kb = parseInt(stdout.trim(), 10);
          if (isNaN(kb)) return resolve(null);
          resolve(Math.round(kb / 1024));
        }
      );
    }
  });
}

function startStatsPolling(
  serverId: string,
  mainWindow: BrowserWindow,
  ramMB: number,
  framework: string
): void {
  serverReady.set(serverId, false);

  serverStatsData.set(serverId, {
    serverId,
    tps: null,
    memoryUsedMB: null,
    memoryMaxMB: ramMB,
    onlinePlayers: [],
    playerCount: 0,
    maxPlayers: 20,
  });

  // Poll every 10 seconds to reduce CPU overhead (was 3s)
  const timer = setInterval(async () => {
    const stats = serverStatsData.get(serverId);
    if (!stats) return;

    // Always poll process memory (works even before server is fully ready)
    const child = runningServers.get(serverId);
    if (child && child.pid) {
      const lastMemAt = lastMemCommandAt.get(serverId) ?? 0;
      const allowProcessMemory =
        !canUseInServerStats(serverId, framework) || Date.now() - lastMemAt > 15000;
      if (allowProcessMemory) {
        const memMB = await getProcessMemoryMB(child.pid);
        if (memMB !== null) {
          stats.memoryUsedMB = memMB;
        }
      }
    }

    if (!serverReady.get(serverId)) {
      // Still send stats update (even without TPS data)
      sendStats(mainWindow, { ...stats });
      return;
    }

    if (child && child.stdin && !child.stdin.destroyed) {
      if (canUseInServerStats(serverId, framework)) {
        internalPollUntil.set(serverId, Date.now() + 12000);
        child.stdin.write("tps\n");
        // child.stdin.write("memory\n");
      }
    }

    // Send current stats to renderer
    sendStats(mainWindow, { ...stats });
  }, 10000);

  serverStatsTimers.set(serverId, timer);

  // Send initial stats immediately
  const stats = serverStatsData.get(serverId);
  if (stats) {
    const child = runningServers.get(serverId);
    if (child && child.pid) {
      if (!canUseInServerStats(serverId, framework)) {
        getProcessMemoryMB(child.pid).then((memMB) => {
          if (memMB !== null) {
            stats.memoryUsedMB = memMB;
          }
          sendStats(mainWindow, { ...stats });
        });
      } else {
        sendStats(mainWindow, { ...stats });
      }
    } else {
      sendStats(mainWindow, { ...stats });
    }
  }
}

function stopStatsPolling(serverId: string): void {
  const timer = serverStatsTimers.get(serverId);
  if (timer) {
    clearInterval(timer);
    serverStatsTimers.delete(serverId);
  }
  serverStatsData.delete(serverId);
  serverReady.delete(serverId);
  internalPollUntil.delete(serverId);
  userStatsBypassUntil.delete(serverId);
  lastMemCommandAt.delete(serverId);
  disableInServerStats.delete(serverId);
}

export async function refreshServerStatuses(mainWindow: BrowserWindow): Promise<void> {
  const servers = await getServers();
  for (const server of servers) {
    if (server.status === "Online" && !runningServers.has(server.id)) {
      await updateServerStatus(server.id, "Offline");
      sendStatusUpdate(mainWindow, { serverId: server.id, status: "Offline" });
    }
  }
}

export async function startServer(
  serverId: string,
  mainWindow: BrowserWindow
): Promise<{ success: boolean; error?: string }> {
  if (runningServers.has(serverId)) {
    return { success: false, error: "Server is already running" };
  }

  const server = await getServer(serverId);
  if (!server) {
    return { success: false, error: "Server not found" };
  }

  try {
    const args = buildJavaArgs(server.ramMB, server.jarFile || "server.jar");
    
    let javaExecutable = server.javaPath;
    
    if (!javaExecutable) {
      const requiredVersion = getRequiredJavaVersion(server.version);
      sendConsoleLine(mainWindow, serverId, `Checking Java ${requiredVersion} runtime...`, "system");
      try {
        javaExecutable = await ensureJavaInstalled(requiredVersion);
        sendConsoleLine(mainWindow, serverId, `Using Java runtime: ${javaExecutable}`, "system");
      } catch (err) {
        const msg = err instanceof Error ? err.message : String(err);
        sendConsoleLine(mainWindow, serverId, `Failed to setup Java: ${msg}`, "stderr");
        throw new Error(`Java setup failed: ${msg}`);
      }
    } else {
        sendConsoleLine(mainWindow, serverId, `Using custom Java path: ${javaExecutable}`, "system");
    }

    // Ensure CatalystAnalytics plugin is installed if analytics is enabled
    if (server.analyticsEnabled) {
      try {
        const installed = await installCatalystPlugin(server.serverPath);
        if (installed) {
          sendConsoleLine(mainWindow, serverId, "CatalystAnalytics plugin verified.", "system");
        }
      } catch (err) {
        console.error("Failed to install CatalystAnalytics plugin on start:", err);
      }
    }

    // Set JAVA_HOME so the JVM can find lib/jvm.cfg and other internal files
    const spawnEnv = { ...process.env };
    if (javaExecutable && javaExecutable !== "java") {
      spawnEnv.JAVA_HOME = getJavaHome(javaExecutable);
    }

    const child = spawn(javaExecutable || "java", args, {
      cwd: server.serverPath,
      stdio: ["pipe", "pipe", "pipe"],
      env: spawnEnv,
    });

    runningServers.set(serverId, child);

    sendConsoleLine(mainWindow, serverId, "Starting server...", "system");
    await updateServerStatus(serverId, "Online");
    sendStatusUpdate(mainWindow, { serverId, status: "Online" });
    startStatsPolling(serverId, mainWindow, server.ramMB, server.framework);

    // Line-buffered stdout
    let stdoutBuffer = "";
    child.stdout.on("data", (data: Buffer) => {
      stdoutBuffer += data.toString();
      const lines = stdoutBuffer.split("\n");
      stdoutBuffer = lines.pop() || "";
      for (const line of lines) {
        if (line.trim()) {
          const cleanedLine = stripAnsi(line);
          parseStatsFromLine(serverId, cleanedLine);
          if (
            isStatsLine(serverId, cleanedLine) &&
            /Unknown command\. Type "\/help" for help\./.test(cleanedLine)
          ) {
            disableInServerStats.set(serverId, true);
          }
          // Filter out internal stats polling output
          if (!isStatsLine(serverId, cleanedLine)) {
            sendConsoleLine(mainWindow, serverId, line, "stdout");
          }
        }
      }
    });

    // Line-buffered stderr
    let stderrBuffer = "";
    child.stderr.on("data", (data: Buffer) => {
      stderrBuffer += data.toString();
      const lines = stderrBuffer.split("\n");
      stderrBuffer = lines.pop() || "";
      for (const line of lines) {
        if (line.trim()) {
          sendConsoleLine(mainWindow, serverId, line, "stderr");
        }
      }
    });

    child.on("close", async (code) => {
      runningServers.delete(serverId);
      stopStatsPolling(serverId);
      
      // Check if server was restarting (in-game /restart command)
      const wasRestarting = serverRestarting.get(serverId) || false;
      serverRestarting.delete(serverId);
      
      if (!mainWindow.isDestroyed()) {
        sendConsoleLine(
          mainWindow,
          serverId,
          `Server process exited with code ${code}`,
          "system"
        );
      }
      
      // If server was restarting, auto-restart it
      if (wasRestarting) {
        if (!mainWindow.isDestroyed()) {
          sendConsoleLine(
            mainWindow,
            serverId,
            "Detected restart command, restarting server...",
            "system"
          );
        }
        
        // Wait a moment for cleanup
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Restart the server - call startServer which will get fresh server data
        const restartResult = await startServer(serverId, mainWindow);
        if (!restartResult.success && !mainWindow.isDestroyed()) {
          sendConsoleLine(
            mainWindow,
            serverId,
            `Failed to restart server: ${restartResult.error}`,
            "stderr"
          );
          await updateServerStatus(serverId, "Offline");
          sendStatusUpdate(mainWindow, { serverId, status: "Offline" });
          return;
        }
        
        // Check if ngrok is enabled globally and restart tunnel
        const ngrokEnabled = await isNgrokEnabled();
        const hasToken = await isAuthtokenConfigured();
        
        if (ngrokEnabled && hasToken) {
          // Get the server port from properties
          const properties = await getServerProperties(server.serverPath);
          const portProp = properties.find(p => p.key === "server-port");
          const port = portProp ? parseInt(portProp.value, 10) : 25565;
          
          const ngrokResult = await startNgrokTunnel(mainWindow, serverId, port);
          if (ngrokResult.success && ngrokResult.publicUrl && !mainWindow.isDestroyed()) {
            mainWindow.webContents.send("ngrokUrlChanged", {
              serverId,
              publicUrl: ngrokResult.publicUrl,
              port,
              protocol: "tcp"
            });
          }
        }
        return;
      }
      
      await updateServerStatus(serverId, "Offline");
      if (!mainWindow.isDestroyed()) {
        sendStatusUpdate(mainWindow, { serverId, status: "Offline" });
      }
    });

    child.on("error", async (err) => {
      runningServers.delete(serverId);
      stopStatsPolling(serverId);
      if (!mainWindow.isDestroyed()) {
        sendConsoleLine(mainWindow, serverId, `Error: ${err.message}`, "stderr");
      }
      await updateServerStatus(serverId, "Offline");
      if (!mainWindow.isDestroyed()) {
        sendStatusUpdate(mainWindow, { serverId, status: "Offline" });
      }
    });

    return { success: true };
  } catch (err) {
    const msg = err instanceof Error ? err.message : "Unknown error";
    return { success: false, error: msg };
  }
}

export async function stopServer(
  serverId: string
): Promise<{ success: boolean; error?: string }> {
  const child = runningServers.get(serverId);
  if (!child) {
    return { success: false, error: "Server is not running" };
  }

  return new Promise((resolve) => {
    const onClose = () => {
      clearTimeout(timeout);
      // Clear the ngrok URL from server record when server stops
      updateServerSettings(serverId, { ngrokUrl: undefined }).catch(() => {});
      resolve({ success: true });
    };

    // Send graceful "stop" command to MC server
    if (child.stdin && !child.stdin.destroyed) {
      child.stdin.write("stop\n");
    }

    const timeout = setTimeout(() => {
      child.removeListener("close", onClose);
      child.kill("SIGKILL");
      // Clear the ngrok URL from server record when server stops
      updateServerSettings(serverId, { ngrokUrl: undefined }).catch(() => {});
      resolve({ success: true });
    }, 15000);

    child.once("close", onClose);
  });
}

export function sendCommand(serverId: string, command: string): void {
  const child = runningServers.get(serverId);
  if (child && child.stdin && !child.stdin.destroyed) {
    if (/^\s*(tps|memory)\s*$/i.test(command)) {
      userStatsBypassUntil.set(serverId, Date.now() + 6000);
    }
    child.stdin.write(command + "\n");
  }
}

export function isRunning(serverId: string): boolean {
  return runningServers.has(serverId);
}

export async function stopAllServers(): Promise<void> {
  const stopPromises = Array.from(runningServers.keys()).map((id) =>
    stopServer(id)
  );
  await Promise.all(stopPromises);
}

export function getServerLogs(serverId: string): ConsoleLine[] {
  return serverLogs.get(serverId) || [];
}

export async function restartServer(
  serverId: string,
  mainWindow: BrowserWindow
): Promise<{ success: boolean; error?: string }> {
  // Check if server is running
  if (!runningServers.has(serverId)) {
    return { success: false, error: "Server is not running" };
  }

  // Send restart message to console
  sendConsoleLine(mainWindow, serverId, "Restarting server...", "system");

  // Stop the server gracefully
  const stopResult = await stopServer(serverId);
  if (!stopResult.success) {
    return { success: false, error: stopResult.error || "Failed to stop server" };
  }

  // Wait a moment for cleanup
  await new Promise(resolve => setTimeout(resolve, 1000));

  // Start the server again
  const startResult = await startServer(serverId, mainWindow);
  if (!startResult.success) {
    return { success: false, error: startResult.error || "Failed to start server" };
  }

  // Check if ngrok is enabled globally and start tunnel if so
  const ngrokEnabled = await isNgrokEnabled();
  const hasToken = await isAuthtokenConfigured();
  
  if (ngrokEnabled && hasToken) {
    const server = await getServer(serverId);
    if (server) {
      // Get the server port from properties file
      const properties = await getServerProperties(server.serverPath);
      const portProp = properties.find(p => p.key === "server-port");
      const port = portProp ? parseInt(portProp.value, 10) : 25565;
      
      const ngrokResult = await startNgrokTunnel(mainWindow, serverId, port);
      if (ngrokResult.success && ngrokResult.publicUrl && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send("ngrokUrlChanged", {
          serverId,
          publicUrl: ngrokResult.publicUrl,
          port,
          protocol: "tcp"
        });
      }
    }
  }

  return { success: true };
}
